#!/usr/bin/python3.11
"""Renames files in a directory according to a file of canonical file name stubs."""

from __future__ import annotations

import sys
import json
import argparse
import tomllib
from datetime import datetime
from pathlib import Path

class Constants:
    progname = "nomnorm"
    version = "0.2"
    config_file = f"{progname}.config.toml"
    config_file_path = Path.home() / ".config" / progname / config_file
    dir_config = f".{config_file}"

    default_config: str = f"""\
# {progname} configuration toml file
#
# First generated {datetime.now()} by {progname} version {version}
# For information on toml syntax, see https://toml.io/en/
""" """\
profile = "default"

[default]
# Relative or absolute path to the directory containing files to rename
target = "."

# Name of file containing the final filename stubs
stubs_file = "filename_stubs.txt"

# match_groups is a table specifying groups common to many of the file_subs
# and/or the stub_pattern. Each pattern is formatted by calling
# .format(**match_groups) on it to replace instance of {groupname} in the
# pattern with the value of match_groups.groupname in this table.
match_groups.key = '\d{8}-\d{6}'
match_groups.resmp4 = '\d+x\d+\.mp4'

# stub_pattern is used to extract the key and replacement text from the
# filename stubs in stubs_file.
#
# The pattern must contain a group named 'key', which is used as a hash key in
# the dict for looking up which replacement to use for each file matched by
# patterns in the src_pattern array.
#
# The entire text of the matched stub is passed as a keyword parameter named
# 'stub' to the format call for renaming the src files, so the pattern need
# not match more than the key group in the pattern.
#
# The pattern text can contain named match groups.  These are passed as
# keyword arguments to format the replacement text.
stub_pattern = 'zoom[._]{key}(GMT|Z)\..*'

# file_subs is a list of inline dicts, each with two keys:
#
# * pat - regex pattern used to match each filename; must contain the 'key' named group
#   Each pattern has .format() called on it with keywords from match_groups
#   and 'stub_pattern' defined.  The values of match_groups are substituted
#   directly, but the stub_pattern is first itself formatted using the
#   match_groups. To use {} range matching, you will need to double the braces
#   to avoid the format expansion like {{ }}.
#
# * rep - replacement template.  This can contain back-references as well as
#   {} format interpolation parts, since .format() is called on this string
#   with the following keyword parameters:
#   - 'stub' - the text of the filename stub this filename's key matched in the stubs_file
#   - any of the named groups matched from the stub_pattern
#
# For each file, each pattern in this list is tried in order - the first one
# that matches is applied to determine how to match the key and rename the file.
#
# TODO - we could another entry called 'key' that specifies how to form the
# key from the given pattern, allowing key renaming.
file_subs = [
  { pat='{stub_pattern}[_.]{resmp4}', rep='{stub}.\g<resmp4>' },
  { pat='{stub_pattern}[_.]?(new)?[Cc]hat\.txt', rep='{stub}.chat.txt' },
  { pat='{stub_pattern}\.m4a', rep='{stub}.m4a' },
  { pat='GMT{key}_Recording_{resmp4}', rep='{stub}.\g<resmp4>' },
  { pat='GMT{key}_RecordingnewChat.txt', rep='{stub}.chat.txt' },
  { pat='GMT{key}_Recording.m4a', rep='{stub}.m4a' },
]

# When true, the script uses the parsed timestamp as a GMT timestamp, and
# updates the file's last-update (modification) time to match.
set_file_mtime = true
"""

class GetAttrDict(dict):
    def __getattr__(self, key): return self[key]

    @staticmethod
    def attrify(struct: list|dict|Any) -> list|GetAttrDict|Any:
        """Walks the given list/dict struct and returns a GetAttrDict-ified one.

        The returned struct is identical except all dict-like instances are
        replaced with new shallow copies as GetAttrDict instances.
        """
        if isinstance(struct, dict):
            return GetAttrDict((k, GetAttrDict.attrify(v)) for k, v in struct.items())
        elif isinstance(struct, list):
            return [GetAttrDict.attrify(e) for e in struct]
        else:
            return struct

def update_recursive(struct, overrides):
    """\
    When struct is a dict, we can recurse into it and set keys.
    In this case, overrides must also be a dict - it structure must
    match.  We iterate only over the keys in overrides to do the
    replacements.

    If struct[k] exists, we need to recurse into it.
    Otherwise, we just set struct[k] = v
    """
    if isinstance(struct, dict):
        for k, v in overrides.items():
            # If k not in struct, we'll call update_recursive(None, v) which returns v
            struct[k] = update_recursive(struct.get(k), v)
    else:
        # Completely replace the struct if it's not a dict to recurse into
        struct = overrides
    return struct

class ConfigFile:
    """Class for managing toml configs files.

    The loaded config is in the config data member, with all dicts replaced
    with GetAttrDict instances.
    """
    def __init__(self, default: str="") -> None:
        self.default = default
        self.config: GetAttrDict = GetAttrDict()

    def load_file(self, path: Path|str) -> None:
        """Loads a config from the path overriding anything in the current config."""
        with open(path, "rb") as f:
            overrides = GetAttrDict.attrify(tomllib.load(f))
        self.config = update_recursive(self.config, overrides)

    def load_default(self) -> object:
        """Just load the default config, don't mess with the config file"""
        self.config = GetAttrDict.attrify(tomllib.loads(self.default))

    def regenerate_config(self, path) -> object:
        self.rename_config_to_backup(path)
        self.write_default_config(path)

    @staticmethod
    def rename_config_to_backup(path: Path|str) -> None:
        path = Path(path)
        if not path.exists():
            return

        # Get the last modification time of the file
        mtime = path.stat().st_mtime
        timestamp = datetime.utcfromtimestamp(mtime).strftime("%Y%m%dT%H%M%S")

        # Rename the file
        new_path = path.with_name(f"{path.stem}.old.{timestamp}{path.suffix}")
        path.rename(new_path)

        print(f"Previous config file backed up to: {new_path}")

    def write_default_config(self, path: str|Path) -> object:
        with open(path, mode='x') as f:
            f.write(self.default)

    def print(self):
        """Prints the config as json for debug"""
        json.dump(self.config, sys.stdout, indent=1)

def process_command_line() -> argparse.Namespace:
    """Load the command line options"""
    parser = argparse.ArgumentParser(
        prog=Constants.progname,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__,
        epilog="",
    )
    parser.add_argument('dir', nargs="?", default=".", help="directory of files to process")
    parser.add_argument('-c', '--config',
                        help=f"""main .toml config file to load.
                        Set to - to avoid loading any main config.
                        default: {Constants.config_file_path}""")
    parser.add_argument('-d', '--dir-config', default=Constants.dir_config,
                        help=f"""file name of the override config file to load from the dir.
                        Set to - to avoid loading any config from the target dir.""")
    parser.add_argument('-p', '--profile',
                        help="""the profile to select form the config file.
                        This overrides both the --config file and the --dir-config.""")
    parser.add_argument('-s', '--stubs-file',
                        help="""filename of the cononical stub names used for renaming.
                        If this contains no path separators, it's resolved in the target dir.
                        Otherwise, it's resolved relative to the cwd.""")
    parser.add_argument('-w', '--write-config', action='store_true',
                        help=f"""write the default config contents to the selected
                        --config file, which may be the default, and exit""")
    return parser.parse_args()

def main():
    #config = ConfigFile.regenerate_config()
    opts = process_command_line()
    cf = ConfigFile(default=Constants.default_config)

    if opts.write_config:
        cfile = opts.config or Constants.config_file_path
        if cfile == "-":
            print("Error: refusing to write to config file named '-'")
            return 2
        else:
            cf.regenerate_config(cfile)
            return 0

    # Load the main config file
    if not opts.config:
        if Constants.config_file_path.exists():
            cf.load_file(Constants.config_file_path)
        else:
            cf.load_default()

    elif opts.config != "-":
        cf.load_file(opts.config)

    # Load the sub-config file from the target dir
    subconfig = Path(opts.dir) / opts.dir_config
    if subconfig.exists():
        cf.load_file(subconfig)

    cf.print()

    # TODO implement opts.profile and opts.stubs_file

    return 0

if __name__ == "__main__":
    sys.exit(main())
